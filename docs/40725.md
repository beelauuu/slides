---
marp: true
theme: default
class: invert
style: |
    section {
        font-size: 180%;
    }
    footer {
        font-size: .6em;
    }
paginate: true
---
<!-- 
_paginate: false
_class: invert
-->

# <!--fit--> Discussion 16
<!-- 
_footer: "Credits to Adit Bala for the MARP template <3"
-->
### Log base 10 walks into a bar and orders a beer. Bartender says, 'We don’t serve your type here.' Log replies, 'That’s irrational.
Brian Lau
`blau1@umd.edu`

---
## Agenda
<!-- 
_footer: Slides available at [`teaching.beelau.dev`](https://teaching.beelau.dev)
-->
1. Log Lecture
2. Quiz Review
2. Office Hours / Lecture Review
---

## Announcements :mega:
<!-- 
_footer: Slides available at [`teaching.beelau.dev`](https://teaching.beelau.dev)
-->
- `Quiz 3`
    - `Wednesday April 9th`
---
# Log!
- Let's go over/review some basics with regards to logs!
    - Yes, the log from math class.
---
# Understanding Logarithms

- **Definition**: If b<sup>x</sup> = y, then log<sub>b</sub>(y) = x
- **In words**: "The log tells us how many times to multiply the base by itself to get a number"

**Examples**:
- 2<sup>3</sup> = 8 → log<sub>2</sub>(8) = 3
- 10<sup>4</sup> = 10,000 → log<sub>10</sub>(10,000) = 4

---

# Key Properties of Logarithms

- **Domain**: Input must be positive (x > 0)
- **Base**: Must be positive and not equal to 1
- **Output ranges**:
  - For x > 1: log<sub>b</sub>(x) is positive
  - For x = 1: log<sub>b</sub>(1) = 0
  - For 0 < x < 1: log<sub>b</sub>(x) is negative

- **CS Focus**: In computer science, we typically use:
  - Base-2 logarithms (log<sub>2</sub>(x) or lg(x))
  - Integer inputs ≥ 1 (representing problem size)

---

# Powers of 2 Table

| x | 2<sup>n</sup> | log<sub>2</sub>(x) |
|---|-------------|-------|
| 2<sup>0</sup> | 1 | 0 | 
| 2<sup>1</sup> | 2 | 1 |
| 2<sup>4</sup> | 16 | 4 |
| 2<sup>8</sup> | 256 | 8 |
| 2<sup>10</sup> | 1,024 | 10 |
| 2<sup>12</sup> | 4,096 | 12 |
| 2<sup>16</sup> | 65,536 | 16 |

*Essential knowledge for computer scientists!*

---

# Logarithm Identities in CS

- **Product Rule**: log<sub>b</sub>(xy) = log<sub>b</sub>(x) + log<sub>b</sub>(y)
  - Example: log<sub>2</sub>(16×4) = log<sub>2</sub>(16) + log<sub>2</sub>(4) = 4 + 2 = 6

- **Quotient Rule**: log<sub>b</sub>(x/y) = log<sub>b</sub>(x) - log<sub>b</sub>(y)
  - Example: log<sub>2</sub>(32/4) = log<sub>2</sub>(32) - log<sub>2</sub>(4) = 5 - 2 = 3

- **Power Rule**: log<sub>b</sub>(x<sup>k</sup>) = k·log<sub>b</sub>(x)
  - Example: log<sub>2</sub>(8<sup>3</sup>) = 3·log<sub>2</sub>(8) = 3×3 = 9

---

# Logarithmic Reduction: "Halving Until 1"

**Binary Search Analysis**:
- After 1 step: n/2 elements remain
- After 2 steps: n/4 elements remain
- After k steps: n/2<sup>k</sup> elements remain

**Process stops when:**
n/2<sup>k</sup> = 1

**Solving for k:**
n = 2<sup>k</sup>
k = log<sub>2</sub>(n)

→ Binary search takes O(log n) time

---

# Logarithms in Big-O Notation

**Common logarithmic algorithms:**
- Binary search: O(log n)
- Balanced search trees (BST, AVL): O(log n)
- Heap operations: O(log n)

**Why ignore the base in Big-O?**
- Change-of-base formula: log<sub>a</sub>(n) = log<sub>b</sub>(n)/log<sub>b</sub>(a)
- Example: log<sub>10</sub>(n) = log<sub>2</sub>(n)/log<sub>2</sub>(10)
- Since 1/log<sub>2</sub>(10) is a constant, bases only differ by a constant factor

Therefore: O(log<sub>2</sub>(n)), O(log<sub>10</sub>(n)), O(ln(n)) are all equivalent

---

# Logarithmic Growth is Slow

**What happens when input size doubles?**

If input size is n → runtime is O(log n)
If input size is 2n → runtime is O(log(2n))

Using Product Rule:
log(2n) = log(2) + log(n) = 1 + log(n)

**Key insight**: When input doubles, runtime increases by just ONE step!

This is why logarithmic algorithms are highly efficient for large datasets.

---
# Thank you! Any questions?

### Remember to give feedback if you have any!
